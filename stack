.eqv PRINT_INT 1
.eqv PRINT_STRING 4
.eqv PRINT_CHAR 11
.eqv INPUT_INT 5
.eqv SYS_EXIT 10

.data

# the array that would hold stack elements
arr: .word 0:100
index: .word -4
	
endl:		.asciiz  "\n" 
space:		.asciiz  " "
label_arr:	.asciiz  "Current elemnets: "
label_inst:	.asciiz  "Enter 1 to push, 2 to pop, 3 to find max, 4 to rotate, 0 to exit\n"
label_invalid:	.asciiz  "Invalid option \n"
label_empty:	.asciiz  "Array is empty \n"
label_max:	.asciiz  "Max is: "

.text														
main:					
		#show the list of options	
		li $v0, PRINT_STRING 
		la $a0, label_inst
		syscall
		
		#setting up options
		li $s0, 0
		li $s1, 1
		li $s2, 2
		li $s3, 3
		li $s4, 4
		
		#get user input
		li $v0, INPUT_INT
		syscall
		move $s5, $v0
		
		#check if valid input
		bltz $s5, invalid  
		bgt $s5, $s4, invalid
		
		#Check which options
		beqz $s5, exit #option 0
		#If option 1
		#If option 2
		#If option 3
		#If opion 4
		
		
			
exit:
	li $v0, SYS_EXIT
	syscall
print_arr:
		#$t0 = 0
		
	#while: beq $t0, index, main	//remember put index value into register to use it
		#print at array[t0]
		#$t0 += 4
		#j while
push:
	#index += 4
	#array[index] = input
	#j print_array
pop:
	#if input < 0, j invalid
max:

rotate:
	#temp for index 0, then array[current(0)] = array[current + 4], loop until Index limit met
invalid:
		li $v0, PRINT_STRING
		la $a0, label_invalid
		syscall
		j main

